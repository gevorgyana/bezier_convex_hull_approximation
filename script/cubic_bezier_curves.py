from scipy.spatial import ConvexHull
import numpy as np

num_points_in_dataset = 4

# should be more than 2
assert(num_points_in_dataset > 2)

# generate the points and build a real convex hull from them
#points = np.random.rand(num_points_in_dataset, 2)
# then convert them to usual lists

points = [[1, 1], [2, 3], [2, 2], [5, 5]]

print ("The points")
for point in points:
    print(point)
print()

# hull indices are a sorted set of indices that make up the
# convex hull

hull = ConvexHull(points)
print ("The convex hull constits of the following points (in indices)")
for i in hull.vertices:
    print(i)
print()

# The idea of the algorithm is to create a better point representation
# of the initial convex hull in terms of points, and then build multiple
# Bezier curves from them. Here is the article that I learned this from
# http://www.malinc.se/m/MakingABezierSpline.php

# Generate the better grid first
# todo use enumerates & similar things
print("Generating more granular control points")
print()

granular_points = []

for i in range(len(hull.vertices)):
    # Split the segment of the convex hull, which is generated by
    # the current (i-th) and the next point in it, into three equal
    # segments.
    j = (hull.vertices[ (i + 1) % len(hull.vertices) ])
    i = (hull.vertices[ i ])

    dx = (points[i][0] - points[j][0]) / 3
    dy = (points[i][1] - points[j][1]) / 3

    print(f"Processing the following segment: {i} -> {j}")
    print(f"Obtained the dx: {dx}, dy: {dy}")
    print("Building the following intermediate control points")
    print(f"{points[i][0] - dx}, {points[i][1] - dy}")
    print(f"{points[i][0] - dx * 2}, {points[i][1] - dy * 2}")
    print()

    granular_points.append([points[i][0], points[i][1]])
    granular_points.append([points[i][0] - dx, points[i][1] - dy])
    granular_points.append([points[i][0] - 2 * dx, points[i][1] - 2 * dy])

print("The resulting coarse points are")
print(granular_points)
